/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "media_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace thrift_test {

int _kSizeValues[] = {
  Size::SMALL,
  Size::LARGE
};
const char* _kSizeNames[] = {
  "SMALL",
  "LARGE"
};
const std::map<int, const char*> _Size_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kSizeValues, _kSizeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kPlayerValues[] = {
  Player::JAVA,
  Player::FLASH
};
const char* _kPlayerNames[] = {
  "JAVA",
  "FLASH"
};
const std::map<int, const char*> _Player_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kPlayerValues, _kPlayerNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


Pod::~Pod() throw() {
}


void Pod::__set_message(const std::string& val) {
  this->message = val;
}

void Pod::__set_pod(const Pod& val) {
  this->pod = val;
__isset.pod = true;
}

uint32_t Pod::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pod.read(iprot);
          this->__isset.pod = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Pod::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Pod");

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pod) {
    xfer += oprot->writeFieldBegin("pod", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->pod.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Pod &a, Pod &b) {
  using ::std::swap;
  swap(a.message, b.message);
  swap(a.pod, b.pod);
  swap(a.__isset, b.__isset);
}

Pod::Pod(const Pod& other0) {
  message = other0.message;
  pod = other0.pod;
  __isset = other0.__isset;
}
Pod& Pod::operator=(const Pod& other1) {
  message = other1.message;
  pod = other1.pod;
  __isset = other1.__isset;
  return *this;
}
void Pod::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Pod(";
  out << "message=" << to_string(message);
  out << ", " << "pod="; (__isset.pod ? (out << to_string(pod)) : (out << "<null>"));
  out << ")";
}


Image::~Image() throw() {
}


void Image::__set_uri(const std::string& val) {
  this->uri = val;
}

void Image::__set_title(const std::string& val) {
  this->title = val;
__isset.title = true;
}

void Image::__set_width(const int32_t val) {
  this->width = val;
}

void Image::__set_height(const int32_t val) {
  this->height = val;
}

void Image::__set_size(const Size::type val) {
  this->size = val;
}

uint32_t Image::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_width = false;
  bool isset_height = false;
  bool isset_size = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uri);
          this->__isset.uri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          this->__isset.title = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->width);
          isset_width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->height);
          isset_height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->size = (Size::type)ecast2;
          isset_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_width)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_height)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_size)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Image::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Image");

  xfer += oprot->writeFieldBegin("uri", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->uri);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.title) {
    xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->title);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32((int32_t)this->size);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Image &a, Image &b) {
  using ::std::swap;
  swap(a.uri, b.uri);
  swap(a.title, b.title);
  swap(a.width, b.width);
  swap(a.height, b.height);
  swap(a.size, b.size);
  swap(a.__isset, b.__isset);
}

Image::Image(const Image& other3) {
  uri = other3.uri;
  title = other3.title;
  width = other3.width;
  height = other3.height;
  size = other3.size;
  __isset = other3.__isset;
}
Image& Image::operator=(const Image& other4) {
  uri = other4.uri;
  title = other4.title;
  width = other4.width;
  height = other4.height;
  size = other4.size;
  __isset = other4.__isset;
  return *this;
}
void Image::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Image(";
  out << "uri=" << to_string(uri);
  out << ", " << "title="; (__isset.title ? (out << to_string(title)) : (out << "<null>"));
  out << ", " << "width=" << to_string(width);
  out << ", " << "height=" << to_string(height);
  out << ", " << "size=" << to_string(size);
  out << ")";
}


Media::~Media() throw() {
}


void Media::__set_uri(const std::string& val) {
  this->uri = val;
}

void Media::__set_title(const std::string& val) {
  this->title = val;
__isset.title = true;
}

void Media::__set_width(const int32_t val) {
  this->width = val;
}

void Media::__set_height(const int32_t val) {
  this->height = val;
}

void Media::__set_format(const std::string& val) {
  this->format = val;
}

void Media::__set_duration(const int64_t val) {
  this->duration = val;
}

void Media::__set_size(const int64_t val) {
  this->size = val;
}

void Media::__set_bitrate(const int32_t val) {
  this->bitrate = val;
__isset.bitrate = true;
}

void Media::__set_person(const std::vector<std::string> & val) {
  this->person = val;
}

void Media::__set_player(const Player::type val) {
  this->player = val;
}

void Media::__set_copyright(const std::string& val) {
  this->copyright = val;
__isset.copyright = true;
}

void Media::__set_pods(const std::vector<Pod> & val) {
  this->pods = val;
}

uint32_t Media::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_width = false;
  bool isset_height = false;
  bool isset_format = false;
  bool isset_duration = false;
  bool isset_size = false;
  bool isset_person = false;
  bool isset_player = false;
  bool isset_pods = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->uri);
          this->__isset.uri = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          this->__isset.title = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->width);
          isset_width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->height);
          isset_height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->format);
          isset_format = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->duration);
          isset_duration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->size);
          isset_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bitrate);
          this->__isset.bitrate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->person.clear();
            uint32_t _size5;
            ::apache::thrift::protocol::TType _etype8;
            xfer += iprot->readListBegin(_etype8, _size5);
            this->person.resize(_size5);
            uint32_t _i9;
            for (_i9 = 0; _i9 < _size5; ++_i9)
            {
              xfer += iprot->readString(this->person[_i9]);
            }
            xfer += iprot->readListEnd();
          }
          isset_person = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->player = (Player::type)ecast10;
          isset_player = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->copyright);
          this->__isset.copyright = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->pods.clear();
            uint32_t _size11;
            ::apache::thrift::protocol::TType _etype14;
            xfer += iprot->readListBegin(_etype14, _size11);
            this->pods.resize(_size11);
            uint32_t _i15;
            for (_i15 = 0; _i15 < _size11; ++_i15)
            {
              xfer += this->pods[_i15].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_pods = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_width)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_height)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_format)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_duration)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_size)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_person)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_player)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_pods)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Media::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Media");

  xfer += oprot->writeFieldBegin("uri", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->uri);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.title) {
    xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->title);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("format", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->format);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("duration", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->duration);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("size", ::apache::thrift::protocol::T_I64, 7);
  xfer += oprot->writeI64(this->size);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.bitrate) {
    xfer += oprot->writeFieldBegin("bitrate", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->bitrate);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("person", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->person.size()));
    std::vector<std::string> ::const_iterator _iter16;
    for (_iter16 = this->person.begin(); _iter16 != this->person.end(); ++_iter16)
    {
      xfer += oprot->writeString((*_iter16));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("player", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32((int32_t)this->player);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.copyright) {
    xfer += oprot->writeFieldBegin("copyright", ::apache::thrift::protocol::T_STRING, 11);
    xfer += oprot->writeString(this->copyright);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("pods", ::apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->pods.size()));
    std::vector<Pod> ::const_iterator _iter17;
    for (_iter17 = this->pods.begin(); _iter17 != this->pods.end(); ++_iter17)
    {
      xfer += (*_iter17).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Media &a, Media &b) {
  using ::std::swap;
  swap(a.uri, b.uri);
  swap(a.title, b.title);
  swap(a.width, b.width);
  swap(a.height, b.height);
  swap(a.format, b.format);
  swap(a.duration, b.duration);
  swap(a.size, b.size);
  swap(a.bitrate, b.bitrate);
  swap(a.person, b.person);
  swap(a.player, b.player);
  swap(a.copyright, b.copyright);
  swap(a.pods, b.pods);
  swap(a.__isset, b.__isset);
}

Media::Media(const Media& other18) {
  uri = other18.uri;
  title = other18.title;
  width = other18.width;
  height = other18.height;
  format = other18.format;
  duration = other18.duration;
  size = other18.size;
  bitrate = other18.bitrate;
  person = other18.person;
  player = other18.player;
  copyright = other18.copyright;
  pods = other18.pods;
  __isset = other18.__isset;
}
Media& Media::operator=(const Media& other19) {
  uri = other19.uri;
  title = other19.title;
  width = other19.width;
  height = other19.height;
  format = other19.format;
  duration = other19.duration;
  size = other19.size;
  bitrate = other19.bitrate;
  person = other19.person;
  player = other19.player;
  copyright = other19.copyright;
  pods = other19.pods;
  __isset = other19.__isset;
  return *this;
}
void Media::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Media(";
  out << "uri=" << to_string(uri);
  out << ", " << "title="; (__isset.title ? (out << to_string(title)) : (out << "<null>"));
  out << ", " << "width=" << to_string(width);
  out << ", " << "height=" << to_string(height);
  out << ", " << "format=" << to_string(format);
  out << ", " << "duration=" << to_string(duration);
  out << ", " << "size=" << to_string(size);
  out << ", " << "bitrate="; (__isset.bitrate ? (out << to_string(bitrate)) : (out << "<null>"));
  out << ", " << "person=" << to_string(person);
  out << ", " << "player=" << to_string(player);
  out << ", " << "copyright="; (__isset.copyright ? (out << to_string(copyright)) : (out << "<null>"));
  out << ", " << "pods=" << to_string(pods);
  out << ")";
}


MediaContent::~MediaContent() throw() {
}


void MediaContent::__set_image(const std::vector<Image> & val) {
  this->image = val;
}

void MediaContent::__set_media(const Media& val) {
  this->media = val;
}

uint32_t MediaContent::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_image = false;
  bool isset_media = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->image.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->image.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += this->image[_i24].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_image = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->media.read(iprot);
          isset_media = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_image)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_media)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t MediaContent::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MediaContent");

  xfer += oprot->writeFieldBegin("image", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->image.size()));
    std::vector<Image> ::const_iterator _iter25;
    for (_iter25 = this->image.begin(); _iter25 != this->image.end(); ++_iter25)
    {
      xfer += (*_iter25).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("media", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->media.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MediaContent &a, MediaContent &b) {
  using ::std::swap;
  swap(a.image, b.image);
  swap(a.media, b.media);
}

MediaContent::MediaContent(const MediaContent& other26) {
  image = other26.image;
  media = other26.media;
}
MediaContent& MediaContent::operator=(const MediaContent& other27) {
  image = other27.image;
  media = other27.media;
  return *this;
}
void MediaContent::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MediaContent(";
  out << "image=" << to_string(image);
  out << ", " << "media=" << to_string(media);
  out << ")";
}

} // namespace
